---
title: 正则表达式大全
date: 2022-01-31 22:37:42 +0800
category: 基础知识与问题技巧
tags: 正则表达式
excerpt: 整理了一些常用的正则表达式
---



## 正则表达式大全

- **`正则表达式`** (Regular Expression)—在计算机科学中，是指一个用来描述或者匹配一系列符合某个句法规则的字符串的单个字符串。

### 常用正则表达式

>正则表达式用于字符串处理、表单验证等场合，实用高效，现将一些常用的表达式收集于此，以备不时之需

```Regular Expression
用户名：/^[a-z0-9_-]{3,16}$/

密码：/^[a-z0-9_-]{6,18}$/

十六进制值：/^#?([a-f0-9]{6}|[a-f0-9]{3})$/

电子邮箱：/^([a-z0-9_\.-]+)@([\da-z\.-]+)\.([a-z\.]{2,6})$/

URL：/^(https?:\/\/)?([\da-z\.-]+)\.([a-z\.]{2,6})([\/\w \.-]*)*\/?$/

IP地址：/^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/

HTML标签：/^<([a-z]+)([^<]+)*(?:>(.*)<\/\1>|\s+\/>)$/

Unicode编码中的汉字范围：/^[u4e00-u9fa5],{0,}$/

匹配中文字符的正则表达式：[\u4e00-\u9fa5]
注：匹配中文还真是个头疼的事，有了这个表达式就好办了

匹配双字节字符(包括汉字在内)：[^\x00-\xff]
注：可以用来计算字符串的长度（一个双字节字符长度计2，ASCII字符计1）

匹配空白行的正则表达式：\n\s*\r
注：可以用来删除空白行

匹配HTML标记的正则表达式：<(\S*?)[^>]*>.*?</\1>|<.*? />
注：网上流传的版本太糟糕，上面这个也仅仅能匹配部分，对于复杂的嵌套标记依旧无能为力

匹配首尾空白字符的正则表达式：^\s*|\s*$
注：可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式

匹配Email地址的正则表达式：\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*
注：表单验证时很实用

匹配网址URL的正则表达式：[a-zA-z]+://[^\s]*
注：网上流传的版本功能很有限，上面这个基本可以满足需求

匹配帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]{4,15}$
注：表单验证时很实用

匹配电话号码：\d{3}-\d{8}|\d{4}-\d{7}
注：匹配形式如 0511-4405222 或 021-87888822

匹配QQ号：[1-9][0-9]{4,}
注：QQ号从10000开始

匹配邮政编码：[1-9]\d{5}(?!\d)
注：国内邮政编码为6位数字

匹配身份证：\d{15}|\d{18}
注：国内的身份证为15位或18位

匹配ip地址：\d+\.\d+\.\d+\.\d+
注：提取ip地址时有用

匹配特定数字：
^[1-9]\d*$        //匹配正整数
^-[1-9]\d*$       //匹配负整数
^-?[1-9]\d*$      //匹配整数
^[1-9]\d*|0$      //匹配非负整数（正整数 + 0）
^-[1-9]\d*|0$     //匹配非正整数（负整数 + 0）
^[1-9]\d*\.\d*|0\.\d*[1-9]\d*$        //匹配正浮点数
^-([1-9]\d*\.\d*|0\.\d*[1-9]\d*)$     //匹配负浮点数
^-?([1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0)$        //匹配浮点数
^[1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0$            //匹配非负浮点数（正浮点数 + 0）
^(-([1-9]\d*\.\d*|0\.\d*[1-9]\d*))|0?\.0+|0$       //匹配非正浮点数（负浮点数 + 0）
注：处理大量数据时有用，具体应用时注意修正

匹配特定字符串：
^[A-Za-z]+$        //匹配由26个英文字母组成的字符串
^[A-Z]+$           //匹配由26个英文字母的大写组成的字符串
^[a-z]+$           //匹配由26个英文字母的小写组成的字符串
^[A-Za-z0-9]+$     //匹配由数字和26个英文字母组成的字符串
^\w+$              //匹配由数字、26个英文字母或者下划线组成的字符串
```

---

###  表达式全集

> 正则表达式有多种不同的风格，下表是在PCRE中元字符及其在正则表达式上下文中的行为的一个完整列表
>
> 注：[PCRE](http://www.pcre.org/ '点击链接前往官网') (Perl Compatible Regular Expressions) 是一个用C语言编写的正则表达式函数库

|    字符     | 描述                                                         |
| :---------: | ------------------------------------------------------------ |
|      \      | 将下一个字符标记为一个特殊字符、或一个原义字符、或一个向后引用、或一个八进制转义符。例如，`n` 匹配字符 `n` 。`\n` 匹配一个换行符。序列 `\\` 匹配 `\` 而 `\(` 则匹配 ``(`` 。 |
|      ^      | 匹配输入字符串的开始位置。如果设置了RegExp对象的Multiline属性，`^` 也匹配 `\n` 或 `\r` 之后的位置。 |
|      $      | 匹配输入字符串的结束位置。如果设置了RegExp对象的Multiline属性，`$` 也匹配 `\n` 或 `\r` 之前的位置。 |
|      *      | 匹配前面的子表达式零次或多次。例如，`zo*` 能匹配 `z` 以及 `zoo` 。`*` 等价于 `{0,}` 。 |
|      +      | 匹配前面的子表达式一次或多次。例如，`zo+` 能匹配 `zo` 以及 `zoo` ，但不能匹配 `z` 。`+` 等价于 `{1,}` 。 |
|      ?      | 匹配前面的子表达式零次或一次。例如， `do(es)?` 可以匹配 `do` 或 `does` 中的 `do` 。`?` 等价于 `{0,1}` 。 |
|    {*n*}    | *n*是一个非负整数。匹配确定的*n*次。例如，`o{2}` 不能匹配 `Bob` 中的 `o` ，但是能匹配 `food` 中的两个 `o` 。 |
|   {*n*,}    | *n*是一个非负整数。至少匹配*n*次。例如，“`o{2,}`”不能匹配“`Bob`”中的“`o`”，但能匹配“`foooood`”中的所有o。“`o{1,}`”等价于“`o+`”。“`o{0,}`”则等价于“`o*`”。 |
|  {*n*,*m*}  | *m*和*n*均为非负整数，其中*n*<=*m*。最少匹配*n*次且最多匹配*m*次。例如，`{1,3}` 将匹配 `fooooood` 中的前三个 `o` 。`o{0,1}` 等价于 `o?` 。请注意在逗号和两个数之间不能有空格。 |
|      ?      | 当该字符紧跟在任何一个其他限制符（`*` , `+` , `?` ， `{n}` ， `{n,}` ， `{n,m}` ）后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串 `oooo` ，`o+?` 将匹配单个 `o` ，而 `o+` 将匹配所有 `o` 。 |
|      .      | 匹配除 `\n` 之外的任何单个字符。要匹配包括 `\n` 在内的任何字符，请使用像 `[.\n]` 的模式。 |
|  (pattern)  | 匹配pattern并获取这一匹配。所获取的匹配可以从产生的Matches集合得到，在VBScript中使用SubMatches集合，在 `JScript` 中则使用 `$0…$9` 属性。要匹配圆括号字符，请使用 `\(` 或 `\)` 。 |
| (?:pattern) | 匹配pattern但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用或字符 `(|)` 来组合一个模式的各个部分是很有用。例如 `industr(?:y|ies)` 就是一个比 `industry|industries` 更简略的表达式。 |
| (?=pattern) | 正向预查，在任何匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如， `Windows(?=95|98|NT|2000)` 能匹配 `Windows2000` 中的 `Windows` ，但不能匹配 `Windows3.1` 中的 `Windows` 。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。 |
| (?!pattern) | 负向预查，在任何不匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如 `Windows(?!95|98|NT|2000)` 能匹配 `Windows3.1` 中的 `Windows` ，但不能匹配 `Windows2000` 中的 `Windows` 。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始 |
|    x\|y     | 匹配x或y。例如，`z|food` 能匹配 `z` 或 `food` 。`(z|f)ood` 则匹配 `zood` 或 `food` 。 |
|    [xyz]    | 字符集合。匹配所包含的任意一个字符。例如，`[abc]` 可以匹配 `plain` 中的 `a` 。 |
|   [^xyz]    | 负值字符集合。匹配未包含的任意字符。例如，`[^abc]` 可以匹配 `plain` 中的 `p` 。 |
|    [a-z]    | 字符范围。匹配指定范围内的任意字符。例如，`[a-z]` 可以匹配 `a` 到 `z` 范围内的任意小写字母字符。 |
|   [^a-z]    | 负值字符范围。匹配任何不在指定范围内的任意字符。例如，`[^a-z]` 可以匹配任何不在 `a` 到 `z` 范围内的任意字符。 |
|     \b      | 匹配一个单词边界，也就是指单词和空格间的位置。例如，`er\b` 可以匹配 `never` 中的 `er` ，但不能匹配 `verb` 中的 `er` 。 |
|     \B      | 匹配非单词边界。`er\B` 能匹配 `verb` 中的 `er` ，但不能匹配 `never` 中的 `er` 。 |
|     \cx     | 匹配由x指明的控制字符。例如，`\cM` 匹配一个 `Control-M` 或 `回车符` 。x的值必须为 `A-Z` 或 `a-z` 之一。否则，将 `c` 视为一个原义的 `c` 字符。 |
|     \d      | 匹配一个数字字符。等价于 `[0-9]` 。                          |
|     \D      | 匹配一个非数字字符。等价于 `[^0-9]` 。                       |
|     \f      | 匹配一个换页符。等价于 `\x0c` 和 `\cL` 。                    |
|     \n      | 匹配一个换行符。等价于 `\x0a` 和 `\cJ` 。                    |
|     \r      | 匹配一个回车符。等价于 `\x0d` 和 `\cM` 。                    |
|     \s      | 匹配任何空白字符，包括空格、制表符、换页符等等。等价于 `[\f\n\r\t\v]` 。 |
|     \S      | 匹配任何非空白字符。等价于 `[^\f\n\r\t\v]` 。                |
|     \t      | 匹配一个制表符。等价于 `\x09` 和 `\cI` 。                    |
|     \v      | 匹配一个垂直制表符。等价于 `\x0b` 和 `\cK` 。                |
|     \w      | 匹配包括下划线的任何单词字符。等价于 `[A-Za-z0-9_]` 。       |
|     \W      | 匹配任何非单词字符。等价于 `[^A-Za-z0-9_]` 。                |
|    \x*n*    | 匹配*n*，其中*n*为十六进制转义值。十六进制转义值必须为确定的两个数字长。例如，`\x41` 匹配 `A` 。`\x041` 则等价于 `\x04&1` 。正则表达式中可以使用ASCII编码。 |
|    \num     | 匹配*num*，其中*num*是一个正整数。对所获取的匹配的引用。例如，`(.)\1` 匹配两个连续的相同字符。 |
|     \n      | 标识一个八进制转义值或一个向后引用。如果 `\n` 之前至少 `n` 个获取的子表达式，则 `n` 为向后引用。否则，如果 `n` 为八进制数字 `（0-7）` ，则 `n` 为一个八进制转义值。 |
|     \nm     | 标识一个八进制转义值或一个向后引用。如果 `\nm` 之前至少有 `nm` 个获得子表达式，则 `nm` 为向后引用。如果 `\nm` 之前至少有 `n` 个获取，则 `n` 为一个后跟文字 `m` 的向后引用。如果前面的条件都不满足，若 `n` 和 `m` 均为八进制数字 `（0-7）` ，则 `\nm` 将匹配八进制转义值 `nm` 。 |
|    \nml     | 如果 `n` 为八进制数字 `（0-3）` ，且 `m` 和 `l` 均为八进制数字 `（0-7）` ，则匹配八进制转义值   `nml` 。 |
|    \u*n*    | 匹配 `n` ，其中 `n` 是一个用四个十六进制数字表示的Unicode字符。例如，`\u00A9` 匹配版权符号 `（?）` 。 |

>以下是以PHP的语法所写的示例
>
>验证字符串是否只含数字与英文，字符串长度并在4~16个字符之间 

```php
<?php
$str = 'a1234';
if (preg_match("^[a-zA-Z0-9]{4,16}$", $str)) {
    echo "验证成功";
} else {
    echo "验证失败";
}
?>

以下示例是用 Perl 语言写的，与上面的示例功能相同
print $str = "a1234" =~ m:^[a-zA-Z0-9]{4,16}$: ? "COMFIRM" : "FAILED";
```

---

### 写在后面

#### 👋参考

- [PCRE正则表达式](https://blog.csdn.net/qq_27623337/article/details/53292053?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164376641416780271940938%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&request_id=164376641416780271940938&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-1-53292053.nonecase&utm_term=PCRE&spm=1018.2226.3001.4450 '点击链接前往')

